/*
 *  7.6.25
 *  https://leetcode.com/problems/max-area-of-island/
 */


class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        UnionFind uf = new UnionFind(m * n);
        int[][] dirs = new int[][]{{1,0}, {0,1}};
        boolean hasSeenOne = false;
        for (int i = 0; i < m; i++){
            for (int j = 0; j < n; j++){
                if (grid[i][j] == 1){
                    hasSeenOne = true;
                    int index = i * n + j;
                    for (int[] dir : dirs){
                        int newR = i + dir[0];
                        int newC = j + dir[1];

                    if (newR >= 0 && newR < m && newC >= 0 && newC < n && grid[newR][newC] == 1){
                        int newIndex = newR * n + newC;
                        uf.union(index, newIndex);
                    }
                }
                }
            }
        }
        return hasSeenOne ? Math.max(1, uf.getLargest()) : uf.getLargest();
    }

    static private class UnionFind{
        private int largest;
        private int[] size;
        private int[] parent;

        public UnionFind(int n){
            largest = 0;
            size = new int[n];
            parent = new int[n];
            for (int i = 0; i < n; i++){
                size[i] = 1;
                parent[i] = i;
            }
        }

        public int find(int p){
            if (parent[p] != p){
                parent[p] = find(parent[p]);
            }
            return parent[p];
        }

        public void union(int p, int q){
            int rootP = find(p);
            int rootQ = find(q);

            if (rootP != rootQ){
                if (size[rootP] > size[rootQ]){
                    parent[rootQ] = rootP;
                    size[rootP]+= size[rootQ];
                    largest = Math.max(largest, size[rootP]);
                }else{
                    parent[rootP] = rootQ;
                    size[rootQ]+= size[rootP];
                    largest = Math.max(largest, size[rootQ]);
                }
            }
        }

        public int getLargest(){
            return largest;
        }
    }
}


// 11.26.2025
/*
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int max = 0;
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        for (int row = 0; row < grid.length; row++){
            for (int col = 0; col < grid[0].length; col++){
                if (grid[row][col] == 1 && visited[row][col] == false){
                    max = Math.max(max, getIslandArea(grid, visited, row, col));
                }
            }
        }

        return max;
    }

    private int getIslandArea(int[][] grid, boolean[][] visited, int row, int col){
        visited[row][col] = true;
        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        int area = 1;
        for (int[] dir : dirs){
            int newRow = row + dir[0];
            int newCol = col + dir[1];
            if (newRow >= 0 && newRow < grid.length && newCol >= 0 && newCol < grid[0].length && visited[newRow][newCol] == false && grid[newRow][newCol] == 1){
                area += getIslandArea(grid, visited, newRow, newCol);
            }
        }

        return area;
    }
}class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int max = 0;
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        for (int row = 0; row < grid.length; row++){
            for (int col = 0; col < grid[0].length; col++){
                if (grid[row][col] == 1 && visited[row][col] == false){
                    max = Math.max(max, getIslandArea(grid, visited, row, col));
                }
            }
        }

        return max;
    }

    private int getIslandArea(int[][] grid, boolean[][] visited, int row, int col){
        visited[row][col] = true;
        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        int area = 1;
        for (int[] dir : dirs){
            int newRow = row + dir[0];
            int newCol = col + dir[1];
            if (newRow >= 0 && newRow < grid.length && newCol >= 0 && newCol < grid[0].length && visited[newRow][newCol] == false && grid[newRow][newCol] == 1){
                area += getIslandArea(grid, visited, newRow, newCol);
            }
        }

        return area;
    }
}
*/