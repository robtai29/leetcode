/*
 *  7.6.25
 *  https://leetcode.com/problems/max-area-of-island/
 */


class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        UnionFind uf = new UnionFind(m * n);
        int[][] dirs = new int[][]{{1,0}, {0,1}};
        boolean hasSeenOne = false;
        for (int i = 0; i < m; i++){
            for (int j = 0; j < n; j++){
                if (grid[i][j] == 1){
                    hasSeenOne = true;
                    int index = i * n + j;
                    for (int[] dir : dirs){
                        int newR = i + dir[0];
                        int newC = j + dir[1];

                    if (newR >= 0 && newR < m && newC >= 0 && newC < n && grid[newR][newC] == 1){
                        int newIndex = newR * n + newC;
                        uf.union(index, newIndex);
                    }
                }
                }
            }
        }
        return hasSeenOne ? Math.max(1, uf.getLargest()) : uf.getLargest();
    }

    static private class UnionFind{
        private int largest;
        private int[] size;
        private int[] parent;

        public UnionFind(int n){
            largest = 0;
            size = new int[n];
            parent = new int[n];
            for (int i = 0; i < n; i++){
                size[i] = 1;
                parent[i] = i;
            }
        }

        public int find(int p){
            if (parent[p] != p){
                parent[p] = find(parent[p]);
            }
            return parent[p];
        }

        public void union(int p, int q){
            int rootP = find(p);
            int rootQ = find(q);

            if (rootP != rootQ){
                if (size[rootP] > size[rootQ]){
                    parent[rootQ] = rootP;
                    size[rootP]+= size[rootQ];
                    largest = Math.max(largest, size[rootP]);
                }else{
                    parent[rootP] = rootQ;
                    size[rootQ]+= size[rootP];
                    largest = Math.max(largest, size[rootQ]);
                }
            }
        }

        public int getLargest(){
            return largest;
        }
    }
}