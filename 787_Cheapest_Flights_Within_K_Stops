/*************************************************************
11.28.25, 1.10.26
https://leetcode.com/problems/cheapest-flights-within-k-stops
**************************************************************/

class Solution {
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
        Map<Integer, Map<Integer, Integer>> adjList = new HashMap<>();
        for (int[] flight : flights){
            adjList.computeIfAbsent(flight[0], HashMap::new).put(flight[1], flight[2]);
        }

        int[] minStops = new int[n];
        Arrays.fill(minStops, Integer.MAX_VALUE);

        Queue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>(){
            public int compare(int[] a, int[] b){
                return Integer.compare(a[0], b[0]);
            }
        });

        // cost, city, stop
        pq.add(new int[]{0, src, -1});

        while (!pq.isEmpty()){
            int[] edge = pq.remove();
            int currentCost = edge[0];
            int currentCity = edge[1];
            int currentStops = edge[2];

            if (currentCity == dst){
                return currentCost;
            }
            if (currentStops >= k){
                continue;
            }
            if (currentStops >= minStops[currentCity]){
                continue;
            }
            minStops[currentCity] = currentStops;

            if (adjList.containsKey(currentCity)){
                for (int nextCity : adjList.get(currentCity).keySet()){
                    int price = adjList.get(currentCity).get(nextCity);
                    pq.add(new int[]{currentCost + price, nextCity, currentStops + 1});
                }
            }
        }
        return -1;
    }
}