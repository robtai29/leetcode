/*************************************************************
7.9.22
https://leetcode.com/problems/sender-with-largest-word-count/
**************************************************************/


class Solution {
public String largestWordCount(String[] messages, String[] senders) {
HashMap<String, Integer> map = new HashMap<>();

        for (int i = 0; i < messages.length; i++){
            int count = countWords(messages[i]);
            map.put(senders[i], map.getOrDefault(senders[i], 0) + count);
        }

        return Collections.max(map.keySet(), (a, b) -> map.get(a).compareTo(map.get(b)) == 0 ? a.compareTo(b) : map.get(a).compareTo(map.get(b)));

    }

    private int countWords(String msg){
        if (msg.length() == 0 || msg == null){
            return 0;
        }
        int count = 1;
        for (char ch : msg.toCharArray()){
            if (ch == ' '){
                count++;
            }
        }
        return count;
    }

}


 // 11.12.2025
/*
class Solution {
    public String largestWordCount(String[] messages, String[] senders) {
        Map<String, Integer> counter = new HashMap<>();

        for (int i = 0; i < messages.length; i++){
            int numWords = messages[i].split("\\s+").length;
            counter.put(senders[i], counter.getOrDefault(senders[i], 0) + numWords);
        }

        List<String> list = new LinkedList<>(counter.keySet());

        list.sort(new Comparator<String>(){
            public int compare(String a, String b){
                int rankA = counter.get(a);
                int rankB = counter.get(b);

                return rankA == rankB ? a.compareTo(b) : Integer.compare(rankA, rankB);
            };
        });

        return list.get(list.size() -1);
    }
}
*/

// 12.12.2025
/*
class Solution {
    public String largestWordCount(String[] messages, String[] senders) {
        Map<String, Integer> count = new HashMap<>();

        for (int i = 0; i < messages.length; i++){
            String message = messages[i];
            int num = (int)Arrays.stream(message.split("\\s+")).filter(str -> !str.isEmpty()).count();
            count.put(senders[i], count.getOrDefault(senders[i], 0) + num);
        }

        PriorityQueue<String> maxHeap = new PriorityQueue<>(new Comparator<String>(){
            public int compare(String s1, String s2){
                int rankS1 = count.get(s1);
                int rankS2 = count.get(s2);

                return rankS1 == rankS2 ? s2.compareTo(s1) : Integer.compare(rankS2, rankS1);
            }
        });

        for (String sender : senders){
            maxHeap.add(sender);
        }

        return maxHeap.remove();
    }
}

*/